# Instructions

During your interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again. 同时你需要维护一个程序架构设计文档`arch.md`，每次完成一个编码任务后，需要对`arch.md`进行更新。注意，Lessons不需要事无巨细记录，参考以下规则，在编码时：
1.已移除的机制，已删除的功能不需要记录为learnings
2.通过修改或新增处理机制的问题修复或优化，不直接记录为learnings，应该在程序架构设计说明文档中记录，并区分这个机制是只应用在单独某个功能，还是整体普遍的机制，说明清楚这个机制的设计动机，下次代码修改时应该遵守这些机制
3.重构类修改，和修改机制类似，应该在程序架构设计说明文档中记录
4.编码级问题修改，如API使用错误，类型错误，文件名非法字符修复等，可以记录到learnings

`arch.md`文档，内容必须包括：
1.每个功能模块的整体实现逻辑，涉及哪些机制，模块间的关系
2.功能模块中，函数调用关系，各个函数实现了该功能模块的哪些子功能

# Tools & Resources

`arch.md`是程序架构设计说明文档，需要根据编码任务的完成情况，及时更新。每次编码修改前，如有必要，找到要修改的模块对应的章节参考，避免引入新的bug！！！NOTE: arch.md内容很多，你只关注需要修改模块，不要修改不属于你负责的模块！！！
`Lessons` section in the `.cursorrules` 是编码经验总结，需要根据编码任务的完成情况，精炼地总结关键点。
`update_log.md`是更新日志，你每次完成编码任务后的总结同步输入到这个文件中，该文件只写改动点，不记录经验，经验总结都写在`.cursorrules`中。

# Lessons

## User Specified Lessons
- You have a python venv in ./venv. Use (.\venv\Scripts\activate) in Windows or (source venv/bin/activate) in MacOS to activate it when doing python development. First, to check whether 'uv' is available, use `which uv`. If that's the case, first activate the venv, and then use `uv pip install` to install packages. Otherwise, fall back to `pip`.
- Due to Cursor's limit, when you use `git` and need to submit a multiline commit message, first write the message in a file, and then use `git commit -F <filename>` or commit. And then remove the file. Include "[Cursor] " in the commit message and PR title.
- IMPORTANT: Note that the way to run bash command are different in different operating systems. For example, on Windows, you need to use python instead of python3. On Windows, you are using powershell instead of terminal.

## Cursor learned

### API 使用注意事项

1. **Gemini API 流式输出**：使用 `model.start_chat()` 创建会话，然后用 `send_message_async(stream=True)` 实现流式输出
2. **自定义 AI 指令传递**：使用 XML 标签（如 `<draw_cards>...</draw_cards>`）在 AI 回复中嵌入结构化指令，然后用正则表达式提取
3. **FastAPI 流式响应**：使用 `StreamingResponse` + Server-Sent Events (SSE) 格式（`data: {JSON}\n\n`）
4. **Zustand 持久化**：使用 `persist()` 中间件，配置 `name` 属性指定 localStorage 键名
5. **星盘API JSON格式**：使用 `json=params` 而非 `data=params` 发送请求，确保数组参数正确传递

### 文件路径和命名规范

1. **后端路由文件**：使用复数形式，如 `users.py`, `conversations.py`
2. **前端组件**：使用 PascalCase，如 `ChatMessage.tsx`, `TarotCardDrawer.tsx`
3. **状态管理**：使用 `useXxxStore.ts` 命名，如 `useAuthStore.ts`
4. **API 服务**：统一放在 `services/api.ts`，导出多个 API 对象

### Windows 特定注意事项

- 运行脚本使用 `.bat` 文件
- 激活 venv 使用 `.\venv\Scripts\activate`
- Python 命令使用 `python` 而非 `python3`
- 使用 PowerShell 而非 bash

### macOS 特定注意事项

- **Python 模块导入路径**：在 macOS 上运行 Python 时，当前工作目录是项目根目录，因此不需要 `backend.` 前缀
  - 错误：`from backend.config import CORS_ORIGINS`
  - 正确：`from config import CORS_ORIGINS`
- **端口占用处理**：使用 `lsof -ti:8000 | xargs kill -9` 清理占用端口的进程
- **启动脚本权限**：使用 `chmod +x run_backend.sh` 给脚本添加执行权限

### 编码类问题记录

#### 1. React 状态异步更新与闭包问题

**问题：** React 状态更新是异步的，闭包会捕获旧的状态值

**核心原则：**
1. **避免在闭包中依赖 React 状态** - 闭包捕获的是定义时的值
2. **直接使用函数参数或局部变量** - 确保使用最新的值
3. **不要用 setTimeout 解决状态更新问题** - 治标不治本
4. **内联逻辑而非调用依赖状态的函数** - 减少状态依赖链

**适用场景：**
- 创建对话后立即发送消息
- 状态更新后立即执行依赖该状态的操作
- 任何涉及异步状态更新的场景

#### 2. 外部API数据请求与格式化的同步性

**问题：** 扩展外部API请求参数后，忘记同步更新数据格式化函数，导致新数据无法传递给AI


**核心原则：**
1. **API请求扩展时，必须同步更新数据处理链** - 从获取到格式化到传递，三个环节都要更新
2. **数据流完整性检查** - 通过日志验证数据在每个环节都正确处理
3. **添加调试日志** - 在关键节点打印数据，方便追踪数据流向

**检查清单（扩展外部API数据时）：**
- [ ] 更新API请求参数（如 `params` 字典）
- [ ] 更新数据格式化函数（如 `format_chart_data_to_text()`）
- [ ] 确认数据正确传递给下游（如传递给AI）
- [ ] 添加日志输出，验证每个环节的数据

**适用场景：**
- 扩展星盘API请求的星体、宫位等数据
- 集成任何外部API时扩展请求参数
- 多层数据处理流程的修改
