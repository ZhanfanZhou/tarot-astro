# Instructions

During your interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again. 同时你需要维护一个程序架构设计文档`arch.md`，每次完成一个编码任务后，需要对`arch.md`进行更新。注意，Lessons不需要事无巨细记录，参考以下规则，在编码时：
1.已移除的机制，已删除的功能不需要记录为learnings
2.通过修改或新增处理机制的问题修复或优化，不直接记录为learnings，应该在程序架构设计说明文档中记录，并区分这个机制是只应用在单独某个功能，还是整体普遍的机制，说明清楚这个机制的设计动机，下次代码修改时应该遵守这些机制
3.重构类修改，和修改机制类似，应该在程序架构设计说明文档中记录
4.编码级问题修改，如API使用错误，类型错误，文件名非法字符修复等，可以记录到learnings

`arch.md`文档，内容必须包括：
1.每个功能模块的整体实现逻辑，涉及哪些机制，模块间的关系
2.功能模块中，函数调用关系，各个函数实现了该功能模块的哪些子功能

# Tools & Resources

`arch.md`是程序架构设计说明文档，需要根据编码任务的完成情况，及时更新。每次编码修改前，如有必要，找到要修改的模块对应的章节参考，避免引入新的bug！！！NOTE: arch.md内容很多，你只关注需要修改模块，不要修改不属于你负责的模块！！！
`Lessons` section in the `.cursorrules` 是编码经验总结，需要根据编码任务的完成情况，精炼地总结关键点。
`update_log.md`是更新日志，你每次完成编码任务后的总结同步输入到这个文件中，该文件只写改动点，不记录经验，经验总结都写在`.cursorrules`中。

# Lessons

## User Specified Lessons
- You have a python venv in ./venv. Use (.\venv\Scripts\activate) in Windows or (source venv/bin/activate) in MacOS to activate it when doing python development. First, to check whether 'uv' is available, use `which uv`. If that's the case, first activate the venv, and then use `uv pip install` to install packages. Otherwise, fall back to `pip`.
- Due to Cursor's limit, when you use `git` and need to submit a multiline commit message, first write the message in a file, and then use `git commit -F <filename>` or commit. And then remove the file. Include "[Cursor] " in the commit message and PR title.
- IMPORTANT: Note that the way to run bash command are different in different operating systems. For example, on Windows, you need to use python instead of python3. On Windows, you are using powershell instead of terminal.

## Cursor learned

### API 使用注意事项

1. **Gemini API 流式输出**：使用 `model.start_chat()` 创建会话，然后用 `send_message_async(stream=True)` 实现流式输出
2. **自定义 AI 指令传递**：使用 XML 标签（如 `<draw_cards>...</draw_cards>`）在 AI 回复中嵌入结构化指令，然后用正则表达式提取
3. **FastAPI 流式响应**：使用 `StreamingResponse` + Server-Sent Events (SSE) 格式（`data: {JSON}\n\n`）
4. **Zustand 持久化**：使用 `persist()` 中间件，配置 `name` 属性指定 localStorage 键名
5. **星盘API JSON格式**：使用 `json=params` 而非 `data=params` 发送请求，确保数组参数正确传递

### 文件路径和命名规范

1. **后端路由文件**：使用复数形式，如 `users.py`, `conversations.py`
2. **前端组件**：使用 PascalCase，如 `ChatMessage.tsx`, `TarotCardDrawer.tsx`
3. **状态管理**：使用 `useXxxStore.ts` 命名，如 `useAuthStore.ts`
4. **API 服务**：统一放在 `services/api.ts`，导出多个 API 对象

### Windows 特定注意事项

- 运行脚本使用 `.bat` 文件
- 激活 venv 使用 `.\venv\Scripts\activate`
- Python 命令使用 `python` 而非 `python3`
- 使用 PowerShell 而非 bash

### macOS 特定注意事项

- **Python 模块导入路径**：在 macOS 上运行 Python 时，当前工作目录是项目根目录，因此不需要 `backend.` 前缀
  - 错误：`from backend.config import CORS_ORIGINS`
  - 正确：`from config import CORS_ORIGINS`
- **端口占用处理**：使用 `lsof -ti:8000 | xargs kill -9` 清理占用端口的进程
- **启动脚本权限**：使用 `chmod +x run_backend.sh` 给脚本添加执行权限

### 编码类问题记录

#### 1. Python 闭包变量作用域问题

**问题：** 在 Python 闭包中对外部变量赋值，会导致该变量被视为局部变量，从而在赋值前使用时报 `UnboundLocalError`

**错误信息：** `UnboundLocalError: local variable 'conversation' referenced before assignment`

**解决方案：**
```python
# 错误写法：在闭包中重新赋值外部变量
async def generate():
    # 使用外部变量
    async for event in service.stream_response(conversation.messages):  # ❌ 报错
        ...
        # 后面重新赋值了 conversation
        conversation = await get_conversation(id)  # ❌ 导致前面报错

# 正确写法：使用不同的变量名
async def generate():
    # 使用外部变量
    async for event in service.stream_response(conversation.messages):  # ✅ 正常
        ...
        # 使用不同的变量名
        updated_conv = await get_conversation(id)  # ✅ 避免冲突
```

**核心原则：**
1. Python 在函数定义时扫描代码，看到变量被赋值就认为是局部变量
2. 即使赋值在后面，前面的引用也会报错
3. 在闭包中避免对外部变量重新赋值
4. 需要更新的值使用新变量名（如 `updated_xxx`）

**适用场景：**
- 异步生成器函数中使用外部变量
- 任何闭包需要更新外部变量的场景
- FastAPI 流式响应中的变量管理

#### 2. FastAPI Query 参数声明

**问题：** FastAPI 接口同时接收请求体和查询参数时，需要明确声明参数来源

**错误信息：** 422 Unprocessable Entity

**解决方案：**
```python
# 错误写法：FastAPI 不知道 conversation_id 从哪里来
@router.post("/draw")
async def draw_cards(
    conversation_id: str,  # ❌ 可能被误解为请求体
    draw_request: DrawCardsRequest
):
    ...

# 正确写法：明确指定为查询参数
from fastapi import Query

@router.post("/draw")
async def draw_cards(
    draw_request: DrawCardsRequest,  # 从请求体获取
    conversation_id: str = Query(...)  # ✅ 明确从查询参数获取
):
    ...
```

**核心原则：**
1. Pydantic 模型参数自动从请求体解析
2. 简单类型参数需要明确指定来源（Query, Path, Header 等）
3. 参数顺序：请求体参数在前，其他参数在后（可选但推荐）

**适用场景：**
- POST/PUT 接口同时需要请求体和查询参数
- 需要明确参数来源的所有 FastAPI 接口

#### 3. Gemini API Protobuf 类型序列化

**问题：** Gemini API 返回的函数参数包含 protobuf 类型（`RepeatedComposite`），无法直接被 `json.dumps` 序列化

**错误信息：** `TypeError: Object of type RepeatedComposite is not JSON serializable`

**解决方案：**
```python
# 错误写法
yield f"data: {json.dumps({'draw_cards': func_args})}\n\n"

# 正确写法：先转换为可序列化格式
serializable_args = json.loads(json.dumps(func_args, default=str))
yield f"data: {json.dumps({'draw_cards': serializable_args})}\n\n"
```

**核心原则：**
1. Gemini API 的 `func_call.args` 使用 `dict()` 转换后，嵌套的数组可能仍是 protobuf 类型
2. 使用 `json.dumps(..., default=str)` 可以处理所有不可序列化的对象
3. 再用 `json.loads()` 转回来，得到完全可序列化的 Python 原生类型

**适用场景：**
- 处理 Gemini Function Calling 的参数
- 任何涉及 protobuf 数据的 JSON 序列化
- SSE 流式输出中传递复杂对象

#### 4. React 状态异步更新与闭包问题

**问题：** React 状态更新是异步的，闭包会捕获旧的状态值

**核心原则：**
1. **避免在闭包中依赖 React 状态** - 闭包捕获的是定义时的值
2. **直接使用函数参数或局部变量** - 确保使用最新的值
3. **不要用 setTimeout 解决状态更新问题** - 治标不治本
4. **内联逻辑而非调用依赖状态的函数** - 减少状态依赖链

**适用场景：**
- 创建对话后立即发送消息
- 状态更新后立即执行依赖该状态的操作
- 任何涉及异步状态更新的场景

#### 5. 外部API数据请求与格式化的同步性

**问题：** 扩展外部API请求参数后，忘记同步更新数据格式化函数，导致新数据无法传递给AI


**核心原则：**
1. **API请求扩展时，必须同步更新数据处理链** - 从获取到格式化到传递，三个环节都要更新
2. **数据流完整性检查** - 通过日志验证数据在每个环节都正确处理
3. **添加调试日志** - 在关键节点打印数据，方便追踪数据流向

**检查清单（扩展外部API数据时）：**
- [ ] 更新API请求参数（如 `params` 字典）
- [ ] 更新数据格式化函数（如 `format_chart_data_to_text()`）
- [ ] 确认数据正确传递给下游（如传递给AI）
- [ ] 添加日志输出，验证每个环节的数据

**适用场景：**
- 扩展星盘API请求的星体、宫位等数据
- 集成任何外部API时扩展请求参数
- 多层数据处理流程的修改

#### 6. 多路由功能一致性维护

**问题：** 星座AI和塔罗AI功能不一致，星座AI缺少抽牌接口，导致前端调用失败

**核心原则：**
1. **功能对等性** - 相同功能在不同路由中应该保持一致
2. **接口完整性** - 每个路由都应该有完整的功能接口
3. **前端路由选择** - 根据会话类型动态选择正确的API
4. **错误处理统一** - 相同功能应该有相同的错误处理机制

**检查清单（多路由功能开发时）：**
- [ ] 确认所有相关路由都有对应的接口
- [ ] 前端根据会话类型选择正确的API
- [ ] 功能实现逻辑保持一致
- [ ] 错误处理和状态管理统一
- [ ] 更新架构文档，记录新增功能

**适用场景：**
- 为多个AI类型添加相同功能（如抽牌、星盘等）
- 修复功能不一致导致的调用错误
- 统一多路由的接口设计

#### 7. React 异步回调中的状态闭包陷阱

**问题：** 在异步流程中使用 React 状态来追踪操作，导致重复执行

**症状：** 
- 星座AI获取星盘数据后自动触发AI回复，但这条回复被发送了多次（如3次）
- 使用 `setChartJustFetched(true)` 在回调中设置状态
- 在同一函数后面检查 `if (chartJustFetched)` 时使用的是旧的状态值

**错误写法：**
```typescript
// ❌ 错误：在回调中设置状态，然后依赖该状态判断
const [chartJustFetched, setChartJustFetched] = useState(false);

await astrologyApi.sendMessage(
  conversationId,
  content,
  (chunk) => { /* ... */ },
  async (instruction) => {
    // 设置状态（异步生效）
    setChartJustFetched(true);  // ❌ 标记1：这会加入React批处理队列
  }
);

// 后面的判断使用旧值
if (chartJustFetched) {  // ❌ 这里 chartJustFetched 仍然是 false（闭包捕获的旧值）
  await astrologyApi.sendMessage(...);  // 这导致重复发送
}
```

**正确写法：**
```typescript
// ✅ 正确：使用本地变量追踪，不依赖React状态
let chartWasFetched = false;  // 本地变量，同步生效

await astrologyApi.sendMessage(
  conversationId,
  content,
  (chunk) => { /* ... */ },
  async (instruction) => {
    // 直接修改本地变量（同步，立即生效）
    chartWasFetched = true;  // ✅ 立即生效
  }
);

// 检查本地变量（获取最新值）
if (chartWasFetched) {  // ✅ 这里能获取最新值
  await astrologyApi.sendMessage(...);  // ✅ 只发送一次
}
```

**核心原则：**
1. **异步状态 vs 同步变量**：对于在同一个异步操作周期内需要追踪的状态，使用本地变量而非 React 状态
2. **闭包陷阱**：回调函数捕获的 React 状态是定义时的值，不会自动更新
3. **何时使用 React 状态**：跨函数、跨组件需要共享的状态；需要触发重新渲染的状态
4. **何时使用本地变量**：单个异步操作周期内的临时状态追踪；回调链中的状态同步

**为什么本地变量有效：**
- 不涉及 React 的异步状态更新机制
- 回调函数中对本地变量的修改立即在同一作用域可见
- 在关键决策点能获取最新的值
- 避免了闭包捕获旧值的问题

**适用场景：**
- 获取数据后自动触发后续操作（如星盘获取后自动让AI继续解读）
- 回调链中需要追踪前一个步骤的完成状态
- 单个用户交互流程中的多步操作协调
- 不需要跨组件共享的临时状态
#### 8. Gemini Function Calling 参数类型和流式响应异常处理

**问题：**
1. Gemini Function Calling 返回的参数类型与后端期望类型不匹配，导致 422 错误
2. 流式响应处理中，当 finish_reason=1 时，访问 .text 属性抛出 ValueError

**具体案例（DrawCardsRequest 类型不匹配）：**
- Gemini 函数定义中 spread_type 为 `"type": "string"`（无 enum 约束）
- Gemini 返回的参数是 `{"spread_type": "three_card", ...}`（字符串值）
- Pydantic 模型期望 `spread_type: TarotSpread`（枚举类型）
- 导致验证失败：422 Unprocessable Entity

**解决方案：**
1. **不使用 enum 约束**：在 Gemini 函数定义中移除 enum 约束（如注释掉 `"enum": ["single", "three_card", ...]`）
2. **Pydantic 模型使用 str 类型**：将期望类型改为 `str` 而非 `enum`
   ```python
   # 错误：期望枚举
   class DrawCardsRequest(BaseModel):
       spread_type: TarotSpread  # ❌ 会导致 422 错误
   
   # 正确：接受字符串
   class DrawCardsRequest(BaseModel):
       spread_type: str  # ✅ 接受任何字符串值
   ```
3. **前端类型定义同步更新**：保持前后端类型一致性
   ```typescript
   // 前端也应该使用 string
   export interface DrawCardsRequest {
     spread_type: string;  // ✅ 不使用 TarotSpread 枚举
   }
   ```
4. **流式响应异常处理**：使用 try-except 捕获 ValueError

**核心原则：**
- Gemini 返回的类型是 string，无法自动转换为 Python enum
- 后端 Pydantic 模型应该与 Gemini 实际返回的数据类型匹配
- 前后端类型定义需要同步
- 业务逻辑可以在运行时进行额外的类型验证和转换

**适用场景：**
- Gemini Function Calling 中的所有参数
- 任何 Pydantic 模型直接接收 Gemini 返回数据
- 跨应用边界的类型交互

#### 9. Gemini Function Calling 中 Protobuf 类型序列化问题

**问题：**
Gemini API 返回的 Function Calling 参数中，数组类型（如 `positions`）是 `proto.marshal.collections.repeated.RepeatedComposite` 而不是普通 Python list。使用 `json.dumps(..., default=str)` 序列化时，会把整个 `RepeatedComposite` 对象转换成字符串表示，而不是数组！

**具体表现：**
- 序列化前：`positions = RepeatedComposite(['文本1', '文本2', '文本3'])`  (正确的 protobuf 类型)
- 序列化后：`positions = "['文本1', '文本2', '文本3']"` ❌ (字符串！)
- 前端收到：`positions[0]` = `"["` 而不是 `"文本1"`
- 前端提交：发送字符串 `"['文本1', ...]"` 给后端
- 结果：422 Unprocessable Content（Pydantic 期望 `List[str]` 但收到 `str`）

**根本原因：**
`json.dumps(func_args, default=str)` 中的 `default=str` 会对所有不能被 JSON 序列化的对象调用 `str()` 函数，包括 `RepeatedComposite` 对象。而 `str(RepeatedComposite(...))` 返回的是字符串表示形式。

**解决方案：**
在 JSON 序列化前，先将 `RepeatedComposite` 转换为普通 Python list：

```python
# 修复：在 json.dumps 前转换 RepeatedComposite 为 list
if 'positions' in func_args:
    positions = func_args['positions']
    if hasattr(positions, '__iter__') and not isinstance(positions, (str, dict)):
        # 这是 RepeatedComposite 或其他可迭代对象，转换为 list
        func_args['positions'] = list(positions)

# 然后再进行 JSON 序列化（此时 positions 已经是真正的 list）
serializable_args = json.loads(json.dumps(func_args, default=str))
```

**额外发现 - card_count 类型问题：**
Gemini 返回的 `card_count` 是 `float` (如 `3.0`) 而不是 `int` (3)。虽然 Pydantic 通常会自动转换，但为了保险起见也应该预先转换：

```python
if 'card_count' in func_args and isinstance(func_args['card_count'], float):
    func_args['card_count'] = int(func_args['card_count'])
```

**核心原则：**
- Gemini API 的 protobuf 类型（`RepeatedComposite`）不能直接被 `json.dumps` 序列化
- 在序列化前应该将所有 protobuf 类型转换为原生 Python 类型
- `default=str` 是 fallback 机制，不应该依赖它来处理 protobuf 类型
- 后端发送给前端的数据必须是标准的 JSON 可序列化类型（list, dict, str, int, float, bool, None）

**适用场景：**
- 处理 Gemini Function Calling 的任何数组参数
- 处理任何来自 Gemini API 的 protobuf 数据
- 需要在后端和前端之间传递复杂数据结构的场景

#### 10. FastAPI 可选 Pydantic 模型参数处理

**问题：**
当 FastAPI 接收可选的 Pydantic 模型作为请求体时，如果直接声明参数为 `profile: UserProfile = None`，会导致：
1. 发送 `undefined` 或 `null` 作为请求体时，axios 会发送无效的请求格式
2. 浏览器发送 OPTIONS 预检请求失败（400 错误）
3. 用户看到"游客登录失败"

**错误表现：**
```
INFO:     127.0.0.1:62439 - "OPTIONS /api/users/guest HTTP/1.1" 400 Bad Request
```

**根本原因：**
- 前端发送 `undefined` 或空值时，axios 序列化为不规范的请求体
- FastAPI 的 Pydantic 验证失败，导致预检请求返回 400

**解决方案：**

**1. 后端改进（FastAPI 路由）**
```python
from fastapi import Body

# ❌ 错误写法
@router.post("/guest")
async def create_guest(profile: UserProfile = None):
    ...

# ✅ 正确写法：使用 Body 显式指定默认值
@router.post("/guest")
async def create_guest(profile: UserProfile = Body(default=None)):
    ...
```

**2. 前端改进（Axios 调用）**
```typescript
// ❌ 错误写法：发送 undefined
const response = await api.post('/api/users/guest', profile);

// ✅ 正确写法 1：发送空对象作为默认值
const response = await api.post('/api/users/guest', profile || {});

// ✅ 正确写法 2：条件性包含可选字段
const response = await api.post('/api/users/register', {
  username,
  password,
  ...(profile ? { profile } : {}),  // 只在有值时包含
});
```

**核心原则：**
1. **使用 `Body(default=None)` 显式声明可选参数**
2. **前端应该发送有效的 JSON 对象**（至少是 `{}`）
3. **避免发送 `undefined` 或 `null` 作为整个请求体**
4. **CORS 预检请求需要有效的请求头和格式**

**适用场景：**
- 任何可选的请求体参数
- 使用 Pydantic 模型作为请求体
- 需要支持空或部分填充的数据
- CORS 跨域请求时更加重要

#### 11. Bcrypt 版本兼容性问题

**问题：**
某些 bcrypt 版本与 passlib 不兼容，导致密码哈希失败，返回误导的错误信息。

**症状：**
```
AttributeError: module 'bcrypt' has no attribute '__about__'
ValueError: password cannot be longer than 72 bytes
```

**原因：**
- passlib 尝试读取 bcrypt 的版本信息时出错
- passlib 进入错误代码路径，返回虚假的 72 字节限制错误

**解决方案：**
使用兼容的版本组合：
```bash
pip uninstall -y bcrypt passlib
pip install passlib==1.7.4 bcrypt==4.1.2
```

**检验方式：**
```python
from passlib.context import CryptContext
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
try:
    result = pwd_context.hash("test")
    print("✅ Bcrypt working correctly")
except Exception as e:
    print(f"❌ Bcrypt error: {e}")
```

**适用场景：**
- 处理密码认证的任何项目
- 虚拟环境中安装依赖时遇到类似问题