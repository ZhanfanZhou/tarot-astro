# Instructions

During your interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again. 同时你需要维护一个程序架构设计文档`arch.md`，每次完成一个编码任务后，需要对`arch.md`进行更新。注意，Lessons不需要事无巨细记录，参考以下规则，在编码时：
1.已移除的机制，已删除的功能不需要记录为learnings
2.通过修改或新增处理机制的问题修复或优化，不直接记录为learnings，应该在程序架构设计说明文档中记录，并区分这个机制是只应用在单独某个功能，还是整体普遍的机制，说明清楚这个机制的设计动机，下次代码修改时应该遵守这些机制
3.重构类修改，和修改机制类似，应该在程序架构设计说明文档中记录
4.编码级问题修改，如API使用错误，类型错误，文件名非法字符修复等，可以记录到learnings

`arch.md`文档，内容必须包括：
1.每个功能模块的整体实现逻辑，涉及哪些机制，模块间的关系
2.功能模块中，函数调用关系，各个函数实现了该功能模块的哪些子功能

# Tools & Resources

`arch.md`是程序架构设计说明文档，需要根据编码任务的完成情况，及时更新。每次编码修改前，如有必要，找到要修改的模块对应的章节参考，避免引入新的bug！！！NOTE: arch.md内容很多，你只关注需要修改模块，不要修改不属于你负责的模块！！！
`Lessons` section in the `.cursorrules` 是编码经验总结，需要根据编码任务的完成情况，精炼地总结关键点。
`update_log.md`是更新日志，你每次完成编码任务后的总结同步输入到这个文件中，该文件只写改动点，不记录经验，经验总结都写在`.cursorrules`中。

# Lessons

## User Specified Lessons
- You have a python venv in ./venv. Use (.\venv\Scripts\activate) in Windows or (source venv/bin/activate) in MacOS to activate it when doing python development. First, to check whether 'uv' is available, use `which uv`. If that's the case, first activate the venv, and then use `uv pip install` to install packages. Otherwise, fall back to `pip`.
- Due to Cursor's limit, when you use `git` and need to submit a multiline commit message, first write the message in a file, and then use `git commit -F <filename>` or commit. And then remove the file. Include "[Cursor] " in the commit message and PR title.
- IMPORTANT: Note that the way to run bash command are different in different operating systems. For example, on Windows, you need to use python instead of python3. On Windows, you are using powershell instead of terminal.

## Cursor learned

### API 使用注意事项

1. **Gemini API 流式输出**：使用 `model.start_chat()` 创建会话，然后用 `send_message_async(stream=True)` 实现流式输出
2. **自定义 AI 指令传递**：使用 XML 标签（如 `<draw_cards>...</draw_cards>`）在 AI 回复中嵌入结构化指令，然后用正则表达式提取
3. **FastAPI 流式响应**：使用 `StreamingResponse` + Server-Sent Events (SSE) 格式（`data: {JSON}\n\n`）
4. **Zustand 持久化**：使用 `persist()` 中间件，配置 `name` 属性指定 localStorage 键名
5. **星盘API JSON格式**：使用 `json=params` 而非 `data=params` 发送请求，确保数组参数正确传递

### 文件路径和命名规范

1. **后端路由文件**：使用复数形式，如 `users.py`, `conversations.py`
2. **前端组件**：使用 PascalCase，如 `ChatMessage.tsx`, `TarotCardDrawer.tsx`
3. **状态管理**：使用 `useXxxStore.ts` 命名，如 `useAuthStore.ts`
4. **API 服务**：统一放在 `services/api.ts`，导出多个 API 对象

### Windows 特定注意事项

- 运行脚本使用 `.bat` 文件
- 激活 venv 使用 `.\venv\Scripts\activate`
- Python 命令使用 `python` 而非 `python3`
- 使用 PowerShell 而非 bash

### macOS 特定注意事项

- **Python 模块导入路径**：在 macOS 上运行 Python 时，当前工作目录是项目根目录，因此不需要 `backend.` 前缀
  - 错误：`from backend.config import CORS_ORIGINS`
  - 正确：`from config import CORS_ORIGINS`
- **端口占用处理**：使用 `lsof -ti:8000 | xargs kill -9` 清理占用端口的进程
- **启动脚本权限**：使用 `chmod +x run_backend.sh` 给脚本添加执行权限

### 编码类问题记录

#### 1. Python 闭包变量作用域问题

**问题：** 在 Python 闭包中对外部变量赋值，会导致该变量被视为局部变量，从而在赋值前使用时报 `UnboundLocalError`

**错误信息：** `UnboundLocalError: local variable 'conversation' referenced before assignment`

**解决方案：**
```python
# 错误写法：在闭包中重新赋值外部变量
async def generate():
    # 使用外部变量
    async for event in service.stream_response(conversation.messages):  # ❌ 报错
        ...
        # 后面重新赋值了 conversation
        conversation = await get_conversation(id)  # ❌ 导致前面报错

# 正确写法：使用不同的变量名
async def generate():
    # 使用外部变量
    async for event in service.stream_response(conversation.messages):  # ✅ 正常
        ...
        # 使用不同的变量名
        updated_conv = await get_conversation(id)  # ✅ 避免冲突
```

**核心原则：**
1. Python 在函数定义时扫描代码，看到变量被赋值就认为是局部变量
2. 即使赋值在后面，前面的引用也会报错
3. 在闭包中避免对外部变量重新赋值
4. 需要更新的值使用新变量名（如 `updated_xxx`）

**适用场景：**
- 异步生成器函数中使用外部变量
- 任何闭包需要更新外部变量的场景
- FastAPI 流式响应中的变量管理

#### 2. FastAPI Query 参数声明

**问题：** FastAPI 接口同时接收请求体和查询参数时，需要明确声明参数来源

**错误信息：** 422 Unprocessable Entity

**解决方案：**
```python
# 错误写法：FastAPI 不知道 conversation_id 从哪里来
@router.post("/draw")
async def draw_cards(
    conversation_id: str,  # ❌ 可能被误解为请求体
    draw_request: DrawCardsRequest
):
    ...

# 正确写法：明确指定为查询参数
from fastapi import Query

@router.post("/draw")
async def draw_cards(
    draw_request: DrawCardsRequest,  # 从请求体获取
    conversation_id: str = Query(...)  # ✅ 明确从查询参数获取
):
    ...
```

**核心原则：**
1. Pydantic 模型参数自动从请求体解析
2. 简单类型参数需要明确指定来源（Query, Path, Header 等）
3. 参数顺序：请求体参数在前，其他参数在后（可选但推荐）

**适用场景：**
- POST/PUT 接口同时需要请求体和查询参数
- 需要明确参数来源的所有 FastAPI 接口

#### 3. Gemini API Protobuf 类型序列化

**问题：** Gemini API 返回的函数参数包含 protobuf 类型（`RepeatedComposite`），无法直接被 `json.dumps` 序列化

**错误信息：** `TypeError: Object of type RepeatedComposite is not JSON serializable`

**解决方案：**
```python
# 错误写法
yield f"data: {json.dumps({'draw_cards': func_args})}\n\n"

# 正确写法：先转换为可序列化格式
serializable_args = json.loads(json.dumps(func_args, default=str))
yield f"data: {json.dumps({'draw_cards': serializable_args})}\n\n"
```

**核心原则：**
1. Gemini API 的 `func_call.args` 使用 `dict()` 转换后，嵌套的数组可能仍是 protobuf 类型
2. 使用 `json.dumps(..., default=str)` 可以处理所有不可序列化的对象
3. 再用 `json.loads()` 转回来，得到完全可序列化的 Python 原生类型

**适用场景：**
- 处理 Gemini Function Calling 的参数
- 任何涉及 protobuf 数据的 JSON 序列化
- SSE 流式输出中传递复杂对象

#### 4. React 状态异步更新与闭包问题

**问题：** React 状态更新是异步的，闭包会捕获旧的状态值

**核心原则：**
1. **避免在闭包中依赖 React 状态** - 闭包捕获的是定义时的值
2. **直接使用函数参数或局部变量** - 确保使用最新的值
3. **不要用 setTimeout 解决状态更新问题** - 治标不治本
4. **内联逻辑而非调用依赖状态的函数** - 减少状态依赖链

**适用场景：**
- 创建对话后立即发送消息
- 状态更新后立即执行依赖该状态的操作
- 任何涉及异步状态更新的场景

#### 5. 外部API数据请求与格式化的同步性

**问题：** 扩展外部API请求参数后，忘记同步更新数据格式化函数，导致新数据无法传递给AI


**核心原则：**
1. **API请求扩展时，必须同步更新数据处理链** - 从获取到格式化到传递，三个环节都要更新
2. **数据流完整性检查** - 通过日志验证数据在每个环节都正确处理
3. **添加调试日志** - 在关键节点打印数据，方便追踪数据流向

**检查清单（扩展外部API数据时）：**
- [ ] 更新API请求参数（如 `params` 字典）
- [ ] 更新数据格式化函数（如 `format_chart_data_to_text()`）
- [ ] 确认数据正确传递给下游（如传递给AI）
- [ ] 添加日志输出，验证每个环节的数据

**适用场景：**
- 扩展星盘API请求的星体、宫位等数据
- 集成任何外部API时扩展请求参数
- 多层数据处理流程的修改

#### 6. 多路由功能一致性维护

**问题：** 星座AI和塔罗AI功能不一致，星座AI缺少抽牌接口，导致前端调用失败

**核心原则：**
1. **功能对等性** - 相同功能在不同路由中应该保持一致
2. **接口完整性** - 每个路由都应该有完整的功能接口
3. **前端路由选择** - 根据会话类型动态选择正确的API
4. **错误处理统一** - 相同功能应该有相同的错误处理机制

**检查清单（多路由功能开发时）：**
- [ ] 确认所有相关路由都有对应的接口
- [ ] 前端根据会话类型选择正确的API
- [ ] 功能实现逻辑保持一致
- [ ] 错误处理和状态管理统一
- [ ] 更新架构文档，记录新增功能

**适用场景：**
- 为多个AI类型添加相同功能（如抽牌、星盘等）
- 修复功能不一致导致的调用错误
- 统一多路由的接口设计
